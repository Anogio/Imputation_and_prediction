---
title: "MI"
output: html_document
---

```{r setup, include=FALSE}
library(tidyverse)
library(MLmetrics)
```

```{r}
aux.folder = '../../auxiliary/'
source(paste(aux.folder,'MVN_imputation.R',sep=''), chdir = T)
source(paste(aux.folder,'generate_missing.R',sep=''), chdir = T)
source(paste(aux.folder,'prediction_methods.R',sep=''), chdir = T)
source(paste(aux.folder,'simulation_methods.R',sep=''), chdir = T)
data_folder = '../../../Data/'
dataset = 'abalone'

seed = ceiling(runif(1,1e3,1e5))
print(seed)
``` 

```{r}
lm.predVar = function(X.new, X.fit, fittedM){
  sigma2 = (summary(fittedM)$sigma)**2
  print(sigma2)
  inv.cov = solve(t(X.fit) %*% X.fit)
  z = X.new %*% inv.cov
  res = rowSums(X.new*z)
  print(res)
  return(res * sigma2)
}
```

MI: multiple imputation on train and test
SI: Single imputation on train, multiple on test
MIBS, SIBS: same as before, but the imputation parameters are estimated from bootstrap samples 

```{r}
oneRun = function(args){
  for(name in names(args)){
    assign(name, args[[name]])
  }
  X = X.gen(args)
  y.g = y.gen(X,args)
  
  y = y.g$y
  X = y.g$X
  

  
  spl = train_test_split(X, y, train_prop)
  X.train = spl$X.train
  X.test = spl$X.test
  y.train = spl$y.train
  y.test = spl$y.test
  
  X.train = MCAR.noEmptyLines(X.train, miss_prop)
  X.test = MCAR.noEmptyLines(X.test, miss_prop)
  
  pre.train = prelim.norm2(X.train) 
  pre.test = prelim.norm2(X.test)
  imp.train = em.norm(pre.train)
  
  imp.train.BS = list()
  for(i in 1:m){
    in.BS = base::sample(1:nrow(X.train), nrow(X.train), replace=T)
    X.train.BS = X.train[in.BS,]
    pre.BS = prelim.norm2(X.train.BS)
    imp.train.BS[[i]] = em.norm(pre.BS)
  }
  
  X.train.single.imp = imp.mvnorm.estim(list(thetahat=imp.train,params=getparam.norm(pre.train,imp.train)),X.train)
  
  datasets.train = list()
  datasets.test = list()
  datasets.train.BS = list()
  datasets.test.BS = list()
  for(i in 1:m){
    datasets.train[[i]] = imp.norm(pre.train,imp.train,X.train)
    datasets.test[[i]] = imp.norm(pre.test, imp.train, X.test)
    datasets.train.BS[[i]] = imp.norm(pre.train,imp.train.BS[[i]], X.train)
    datasets.test.BS[[i]] = imp.norm(pre.test, imp.train.BS[[i]], X.test)
  }
  
  single.imp.fit = (predictor$train)(X.train.single.imp, y.train)
  MI.regressors.fit = lapply(1:m,
                          function(i) {(predictor$train)(datasets.train[[i]], y.train)})
  BS.regressors.fit = lapply(1:m,
                          function(i) {(predictor$train)(datasets.train.BS[[i]], y.train)})
  
  predictions.MI = lapply(1:m, function(i){(predictor$predict)(MI.regressors.fit[[i]], datasets.test[[i]])}) %>% as.data.frame()
  predictions.SI = lapply(1:m, function(i){(predictor$predict)(single.imp.fit, datasets.test[[i]])}) %>% as.data.frame()
  predictions.BS = lapply(1:m, function(i){(predictor$predict)(BS.regressors.fit[[i]], datasets.test.BS[[i]])}) %>% as.data.frame()
  predictions.SIBS = lapply(1:m, function(i){(predictor$predict)(single.imp.fit, datasets.test.BS[[i]])}) %>% as.data.frame()
  
  #MI.quantiles = t(apply(predictions.MI,1,function(x)quantile(x, probs=c(alpha/2,1-alpha/2)))) %>% as.data.frame()
  #SI.quantiles = t(apply(predictions.SI,1,function(x)quantile(x, probs=c(alpha/2,1-alpha/2)))) %>% as.data.frame()
  #BS.quantiles = t(apply(predictions.BS,1,function(x)quantile(x, probs=c(alpha/2,1-alpha/2)))) %>% as.data.frame()
  #SIBS.quantiles = t(apply(predictions.SIBS,1,function(x)quantile(x, probs=c(alpha/2,1-alpha/2)))) %>% as.data.frame()

  MI.var_b = apply(predictions.MI,1,var)
  SI.var_b = apply(predictions.SI,1,var)
  BS.var_b = apply(predictions.BS,1,var)
  SIBS.var_b = apply(predictions.SIBS,1,var)
  
  MI.var_w = lapply(1:m, function(i) lm.predVar(datasets.test[[i]], datasets.train[[i]], MI.regressors.fit[[i]])) %>% as.data.frame() %>% rowMeans()
  SI.var_w = lapply(1:m, function(i) lm.predVar(datasets.test[[i]], X.train.single.imp, single.imp.fit)) %>% as.data.frame() %>% rowMeans()
  BS.var_w = lapply(1:m, function(i) lm.predVar(datasets.test.BS[[i]], datasets.train.BS[[i]], BS.regressors.fit[[i]])) %>% as.data.frame() %>% rowMeans()
  SIBS.var_w = lapply(1:m, function(i) lm.predVar(datasets.test.BS[[i]], X.train.single.imp, single.imp.fit)) %>% as.data.frame() %>% rowMeans()
  
  MI.var_tot = MI.var_w + (1 + 1/m) * MI.var_b
  MI.df = (m-1) * (1 + MI.var_w / ((1+1/m)*MI.var_b))**2
  MI.quantiles = t(sapply(MI.df, function(x) qt(c(alpha/2,1-alpha/2), df=x))) * sqrt(MI.var_tot) + rowMeans(predictions.MI)
  
  SI.var_tot = SI.var_w + (1 + 1/m) * SI.var_b
  SI.df = (m-1) * (1 + SI.var_w / ((1+1/m)*SI.var_b))**2
  SI.quantiles = t(sapply(SI.df, function(x) qt(c(alpha/2,1-alpha/2), df=x))) * sqrt(SI.var_tot) + rowMeans(predictions.SI)
  
  BS.var_tot = BS.var_w + (1 + 1/m) * BS.var_b
  BS.df = (m-1) * (1 + BS.var_w / ((1+1/m)*BS.var_b))**2
  BS.quantiles = t(sapply(BS.df, function(x) qt(c(alpha/2,1-alpha/2), df=x))) * sqrt(BS.var_tot) + rowMeans(predictions.BS)
  
  SIBS.var_tot = SIBS.var_w + (1 + 1/m) * SIBS.var_b
  SIBS.df = (m-1) * (1 + SIBS.var_w / ((1+1/m)*SIBS.var_b))**2
  SIBS.quantiles = t(sapply(SIBS.df, function(x) qt(c(alpha/2,1-alpha/2), df=x))) * sqrt(SIBS.var_tot) + rowMeans(predictions.SIBS)
  
  isCovered = list()
  isCovered$MI = y.test > MI.quantiles[,1] & y.test < MI.quantiles[,2]
  isCovered$SI = y.test > SI.quantiles[,1] & y.test < SI.quantiles[,2]
  isCovered$BS = y.test > BS.quantiles[,1] & y.test < BS.quantiles[,2]
  isCovered$SIBS = y.test > SIBS.quantiles[,1] & y.test < SIBS.quantiles[,2]
  
  return(lapply(isCovered, mean))
}
```

```{r}
X.gen = X.basic.MVN
y.gen = y.regression
predictor = reg.lin
argsL = list(n=800,
            p=seq(2, 30, 4 ),
            rho=0.5,
            sigma_reg = 0.2,
            train_prop=0.6,
            miss_prop=0.3,
            alpha = 0.3,
            m=30
)

S = 10
res.1 = evaluate.S.run.multiArg(S,argsL, oneRun, do.parallel = T) 

res.1 %>% gather('method','error', c(MI, SI, BS, SIBS)) %>% ggplot() + aes(x=p,y=error, color=method) + geom_line() + geom_line(aes(y=1-alpha, color='Nominal coverage'))
```

```{r}
X.gen = X.abalone
y.gen = y.abalone
argsL = list(n=seq(300,2000,200),
            train_prop=0.6,
            miss_prop=0.3,
            alpha = 0.3,
            m=30
)

res.2 = evaluate.S.run.multiArg(S,argsL, oneRun, do.parallel = T) 

res.2 %>% gather('method','error', c(MI, SI, BS, SIBS)) %>% ggplot() + aes(x=n,y=error, color=method) + geom_line() + geom_line(aes(y=1-alpha, color='Nominal coverage'))

```

```{r}
X.gen = X.abalone
y.gen = y.abalone
argsL = list(n=1000,
            train_prop=0.6,
            miss_prop=seq(0,0.8,0.1),
            alpha = 0.3,
            m=30
)

res.3 = evaluate.S.run.multiArg(S,argsL, oneRun, do.parallel = T) 

res.3 %>% gather('method','error', c(MI, SI, BS, SIBS)) %>% ggplot() + aes(x=miss_prop,y=error, color=method) + geom_line() + geom_line(aes(y=1-alpha, color='Nominal coverage'))

```


```{r}
X.gen = X.abalone
y.gen = y.abalone
argsL = list(n=1000,
            train_prop=0.6,
            miss_prop=0.3,
            alpha = seq(0.01,0.3, 0.03),
            m=30
)

res.4 = evaluate.S.run.multiArg(S,argsL, oneRun, do.parallel = T) 

res.4 %>% gather('method','error', c(MI, SI, BS, SIBS)) %>% ggplot() + aes(x=alpha,y=error, color=method) + geom_line() + geom_line(aes(x=alpha, y=1-alpha, color='Nominal coverage'))

```



